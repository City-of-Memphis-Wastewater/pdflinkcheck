# .github/workflows/microsoftstore.yml

name: Build MSIX for Microsoft Store
#name: Build and Publish MSIX to Microsoft Store

on:
  release:
    types: [published]
  push:
    branches: [main, dev] 

jobs:
  build-msix:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install uv
        run: pip install uv

      - name: Ensure updated copies of packaged data files
        run: python src/pdflinkcheck/datacopy.py

      - name: Create venv and install project with extras
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |

          python -m venv .venv
          .\.venv\Scripts\python.exe -m pip install --upgrade pip 
          .\.venv\Scripts\python.exe -m pip install -e ".[full]"
          .\.venv\Scripts\python.exe -m pip install pyinstaller

      - name: Build EXE with PyInstaller
        id: build_exe
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $env:PATH = "$env:GITHUB_WORKSPACE\.venv\Scripts;$env:PATH"
          $script = Join-Path $env:GITHUB_WORKSPACE "build_executable.py"
          $output = .\.venv\Scripts\python.exe $script 2>&1 | Tee-Object -Variable log
          Write-Host "$log"
      
      - name: Debug, list dist folder, after PyInstaller
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          Write-Host "=== Listing  dist/ contents ==="
          Get-ChildItem dist -Recurse -File | Select-Object FullName

      - name: Detect built EXE
        id: detect_exe
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $exe = Get-ChildItem dist -Filter *.exe | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $exe) {
              Write-Error "No EXE found in dist/"
              exit 1
          }
          Write-Host "Detected EXE: $($exe.FullName)"
          "EXE_PATH=$($exe.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Debug EXE_PATH output
        shell: pwsh
        run: |
          Write-Host "EXE_PATH from outputs:"
          Write-Host "${{ steps.detect_exe.outputs.EXE_PATH }}"

      - name: Rename EXE to stable name
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $src = "${{ steps.detect_exe.outputs.EXE_PATH }}"
          $dst = Join-Path "dist" "pdflinkcheck.exe"
          Move-Item -Force $src $dst
              
      - name: Prepare MSIX folder structure
        run: |
          copy dist\pdflinkcheck.exe msix\

      - name: Update AppxManifest version from pyproject.toml
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $env:PATH = "$env:GITHUB_WORKSPACE\.venv\Scripts;$env:PATH"
          $script = Join-Path $env:GITHUB_WORKSPACE "src\pdflinkcheck\update_msix_version.py"
          .\.venv\Scripts\python.exe $script

      - name: Debug, list msix folder, after copying EXE
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          Write-Host "=== Listing  msix/ contents ==="
          Get-ChildItem msix -Recurse -File | Select-Object FullName

      - name: Decode signing certificate
        shell: pwsh
        run: |
          $bytes = [System.Convert]::FromBase64String("${{ secrets.CERT_PFX_PC }}")
          [IO.File]::WriteAllBytes("cert.pfx", $bytes)
      

      - name: Find makeappx
        id: find_makeappx
        shell: pwsh
        run: |
          $path = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter makeappx.exe |
                  Where-Object { $_.FullName -match '\\x64\\' } |
                  Select-Object -First 1 -ExpandProperty FullName
          Write-Host "Found makeappx at: $path"
          echo "MAKEAPPX=$path" >> $env:GITHUB_OUTPUT

      - name: Create MSIX package
        shell: pwsh
        run: |
          & "${{ steps.find_makeappx.outputs.MAKEAPPX }}" pack /d msix /p pdflinkcheck.msix
      
      - name: Find working signtool (primary)
        id: find_signtool_primary
        continue-on-error: true
        shell: pwsh
        run: |
          $paths = @(
            "C:\Program Files (x86)\Windows Kits\10\App Certification Kit\signtool.exe",
            "C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe"
          )

          foreach ($p in $paths) {
            if (Test-Path $p) {
              Write-Host "Using SignTool: $p"
              "SIGNTOOL=$p" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
              exit 0
            }
          }

          Write-Error "No working SignTool found"
          exit 1


      - name: Find working signtool (backup)
        id: find_signtool_backup 
        if: steps.find_signtool_primary.outcome == 'failure'
        shell: pwsh
        run: |
          Write-Host "=== Listing Windows SDK versions ==="
          Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Directory |
              Where-Object { $_.Name -match '^\d+\.\d+\.\d+\.\d+$' } |
              ForEach-Object {
                  Write-Host "Found SDK: $($_.FullName)"
                  $signtool = Join-Path $_.FullName "x64\signtool.exe"
                  if (Test-Path $signtool) {
                      Write-Host "  -> signtool exists: $signtool"
                  } else {
                      Write-Host "  -> signtool missing in x64"
                  }
              }
          Write-Host "=== End of SDK listing ==="

          $tools = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter signtool.exe | 
                 Where-Object { $_.FullName -match '\\x64\\' }
          if ($tools.Count -eq 0) {
            Write-Error "Backup finder found no signtool.exe"
            exit 1
          }
          
          # Sort by version number in the path and get the oldest one
          $path = $tools | Sort-Object FullName | Select-Object -First 1 -ExpandProperty FullName    
          "SIGNTOOL=$path" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Select final SignTool
        id: select_signtool
        shell: pwsh
        run: |
          if ("${{ steps.find_signtool_primary.outputs.SIGNTOOL }}" -and
            "${{ steps.find_signtool_primary.outputs.SIGNTOOL }}" -ne "null") {
            $path = "${{ steps.find_signtool_primary.outputs.SIGNTOOL }}"
          } elseif ("${{ steps.find_signtool_backup.outputs.SIGNTOOL }}" -ne "") {
            $path = "${{ steps.find_signtool_backup.outputs.SIGNTOOL }}"
          } else {
            Write-Error "No SignTool found from either primary or backup"
            exit 1
          }

          Write-Host "Final SignTool: $path"
          "SIGNTOOL=$path" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8


      - name: Debug signtool path 
        run: | 
          echo "Using signtool: ${{ steps.select_signtool.outputs.SIGNTOOL }}"
          
      - name: Sign MSIX package
        shell: pwsh
        run: |
          & "${{ steps.select_signtool.outputs.SIGNTOOL }}" sign `
            /a `
            /fd SHA256 `
            /td SHA256 `
            /tr http://timestamp.digicert.com `
            /f cert.pfx `
            /p "${{ secrets.CERT_PASSWORD_PC }}" `
            pdflinkcheck.msix

      - name: Upload MSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: msix
          path: pdflinkcheck.msix

  publish-to-store:
    needs: build-msix
    runs-on: windows-latest

    steps:
      - name: Download MSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: msix

      # 1. Get OAuth token from Azure AD
      - name: Get OAuth token
        id: get_token
        shell: pwsh
        run: |
          $tenant = "${{ secrets.AZURE_TENANT_ID }}"
          $client = "${{ secrets.STORE_CLIENT_ID }}"
          $secret = "${{ secrets.STORE_CLIENT_SECRET }}"

          $body = @{
            grant_type    = "client_credentials"
            client_id     = $client
            client_secret = $secret
            resource      = "https://manage.devcenter.microsoft.com"
          }

          $response = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/$tenant/oauth2/token" -Body $body
          "TOKEN=$($response.access_token)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      # 2. Upload MSIX to Microsoft Store API
      - name: Publish to Microsoft Store
        shell: pwsh
        run: |
          $token = "${{ steps.get_token.outputs.TOKEN }}"

          curl -X POST `
            -H "Authorization: Bearer $token" `
            -F "package=@pdflinkcheck.msix" `
            "https://manage.devcenter.microsoft.com/v1.0/my/applications/9N11HXVLS1WG/submissions"

