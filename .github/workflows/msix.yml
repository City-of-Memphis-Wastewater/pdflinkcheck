# .github/workflows/microsoftstore.yml

name: Build MSIX for Microsoft Store

on:
  #release:
  #  types: [published]
  #workflow_run:
  #  workflows: ["Check and Publish Python Package to PyPI and Releases"]  # Must match the 'name' field of your first workflow 
  #  types:
  #    - completed
  push:
    #branches: [main, dev]
    branches: [nope] 
  

jobs:
  build-msix:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install uv
        run: pip install uv

      - name: Ensure updated copies of packaged data files
        run: python src/pdflinkcheck/datacopy.py

      - name: Create venv and install project with extras
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |

          python -m venv .venv
          .\.venv\Scripts\python.exe -m pip install --upgrade pip 
          .\.venv\Scripts\python.exe -m pip install -e ".[full]"
          .\.venv\Scripts\python.exe -m pip install pyinstaller

      - name: Build EXE with PyInstaller
        id: build_exe
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $env:PATH = "$env:GITHUB_WORKSPACE\.venv\Scripts;$env:PATH"
          $script = Join-Path $env:GITHUB_WORKSPACE "build_executable.py"
          $output = .\.venv\Scripts\python.exe $script 2>&1 | Tee-Object -Variable log
          Write-Host "$log"
      
      - name: Debug, list dist folder, after PyInstaller
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          Write-Host "=== Listing  dist/ contents ==="
          Get-ChildItem dist -Recurse -File | Select-Object FullName

      - name: Detect built EXE
        id: detect_exe
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $exe = Get-ChildItem dist -Filter *.exe | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $exe) {
              Write-Error "No EXE found in dist/"
              exit 1
          }
          Write-Host "Detected EXE: $($exe.FullName)"
          "EXE_PATH=$($exe.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Debug EXE_PATH output
        shell: pwsh
        run: |
          Write-Host "EXE_PATH from outputs:"
          Write-Host "${{ steps.detect_exe.outputs.EXE_PATH }}"

      - name: Rename EXE to stable name
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $src = "${{ steps.detect_exe.outputs.EXE_PATH }}"
          $dst = Join-Path "dist" "pdflinkcheck.exe"
          Move-Item -Force $src $dst
              
      - name: Prepare MSIX folder structure
        run: |
          copy dist\pdflinkcheck.exe msix\

      - name: Update AppxManifest version from pyproject.toml
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          $env:PATH = "$env:GITHUB_WORKSPACE\.venv\Scripts;$env:PATH"
          $script = Join-Path $env:GITHUB_WORKSPACE "src\pdflinkcheck\update_msix_version.py"
          .\.venv\Scripts\python.exe $script

      - name: Debug, list msix folder, after copying EXE
        shell: pwsh
        working-directory: ${{ github.workspace }}
        run: |
          Write-Host "=== Listing  msix/ contents ==="
          Get-ChildItem msix -Recurse -File | Select-Object FullName

      - name: Decode signing certificate
        shell: pwsh
        run: |
          $bytes = [System.Convert]::FromBase64String("${{ secrets.CERT_PFX_PC }}")
          [IO.File]::WriteAllBytes("cert.pfx", $bytes)
      

      - name: Find makeappx
        id: find_makeappx
        shell: pwsh
        run: |
          $path = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter makeappx.exe |
                  Where-Object { $_.FullName -match '\\x64\\' } |
                  Select-Object -First 1 -ExpandProperty FullName
          Write-Host "Found makeappx at: $path"
          echo "MAKEAPPX=$path" >> $env:GITHUB_OUTPUT

      - name: Create MSIX package
        shell: pwsh
        run: |
          & "${{ steps.find_makeappx.outputs.MAKEAPPX }}" pack /d msix /p pdflinkcheck.msix
      
      - name: Find working signtool (primary)
        id: find_signtool_primary
        continue-on-error: true
        shell: pwsh
        run: |
          $paths = @(
            "C:\Program Files (x86)\Windows Kits\10\App Certification Kit\signtool.exe",
            "C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe"
          )

          foreach ($p in $paths) {
            if (Test-Path $p) {
              Write-Host "Using SignTool: $p"
              "SIGNTOOL=$p" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
              exit 0
            }
          }

          Write-Error "No working SignTool found"
          exit 1


      - name: Find working signtool (backup)
        id: find_signtool_backup 
        if: steps.find_signtool_primary.outcome == 'failure'
        shell: pwsh
        run: |
          Write-Host "=== Listing Windows SDK versions ==="
          Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Directory |
              Where-Object { $_.Name -match '^\d+\.\d+\.\d+\.\d+$' } |
              ForEach-Object {
                  Write-Host "Found SDK: $($_.FullName)"
                  $signtool = Join-Path $_.FullName "x64\signtool.exe"
                  if (Test-Path $signtool) {
                      Write-Host "  -> signtool exists: $signtool"
                  } else {
                      Write-Host "  -> signtool missing in x64"
                  }
              }
          Write-Host "=== End of SDK listing ==="

          $tools = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter signtool.exe | 
                 Where-Object { $_.FullName -match '\\x64\\' }
          if ($tools.Count -eq 0) {
            Write-Error "Backup finder found no signtool.exe"
            exit 1
          }
          
          # Sort by version number in the path and get the oldest one
          $path = $tools | Sort-Object FullName | Select-Object -First 1 -ExpandProperty FullName    
          "SIGNTOOL=$path" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Select final SignTool
        id: select_signtool
        shell: pwsh
        run: |
          if ("${{ steps.find_signtool_primary.outputs.SIGNTOOL }}" -and
            "${{ steps.find_signtool_primary.outputs.SIGNTOOL }}" -ne "null") {
            $path = "${{ steps.find_signtool_primary.outputs.SIGNTOOL }}"
          } elseif ("${{ steps.find_signtool_backup.outputs.SIGNTOOL }}" -ne "") {
            $path = "${{ steps.find_signtool_backup.outputs.SIGNTOOL }}"
          } else {
            Write-Error "No SignTool found from either primary or backup"
            exit 1
          }

          Write-Host "Final SignTool: $path"
          "SIGNTOOL=$path" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8


      - name: Debug signtool path 
        run: | 
          echo "Using signtool: ${{ steps.select_signtool.outputs.SIGNTOOL }}"
          
      - name: Sign MSIX package
        shell: pwsh
        run: |
          & "${{ steps.select_signtool.outputs.SIGNTOOL }}" sign `
            /a `
            /fd SHA256 `
            /td SHA256 `
            /tr http://timestamp.digicert.com `
            /f cert.pfx `
            /p "${{ secrets.CERT_PASSWORD_PC }}" `
            pdflinkcheck.msix

      - name: Upload MSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: msix
          path: pdflinkcheck.msix

  publish-submission:
    needs: build-msix
    if: false
    runs-on: windows-latest

    steps:
      - name: Download MSIX artifact
        if: false
        uses: actions/download-artifact@v4
        with:
          name: msix

      - name: Get OAuth token
        id: get_token
        shell: pwsh
        run: |
          $body = @{
            grant_type    = "client_credentials"
            client_id     = "${{ secrets.ENTRA_CLIENT_ID }}"
            client_secret = "${{ secrets.ENTRA_CLIENT_SECRET }}"
            resource      = "https://manage.devcenter.microsoft.com"
          }

          $response = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/${{ secrets.AZURE_TENANT_ID }}/oauth2/token" -Body $body
          "TOKEN=$($response.access_token)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Create submission
        id: create_submission_eager
        if: false
        shell: pwsh
        run: |
          $token = "${{ steps.get_token.outputs.TOKEN }}"
          $appId = "9N11HXVLS1WG"

          $submission = Invoke-RestMethod `
            -Method POST `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$appId/submissions" `
            -Headers @{ Authorization = "Bearer $token" } `
            -ContentType "application/json"

          $submission | ConvertTo-Json -Depth 20 | Out-File submission.json

          "SUBMISSION_ID=$($submission.id)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "UPLOAD_URL=$($submission.fileUploadUrl)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
      
      - name: Create submission (with retry)
        id: create_submission
        if: false
        shell: pwsh
        run: |
          $token = "${{ steps.get_token.outputs.TOKEN }}"
          $appId = "9N11HXVLS1WG"

          # The Token is known to expire after 1 hour, sotokenExpirarionTimeshoukd not.exceed this
          # Future work: Assess token with credentials inside the loop on each attempt.
          $tokenExpirationTime = 60 # minutes, expected
          $delayMinutes = 21 # what hapoens atexactly 60 min? i'd rather not test it
          $maxRetries = int($tokenExpirationTime/$delayMinutes) # int rounds down and cuts off decimal
          for ($i = 1; $i -le $maxRetries; $i++) {

            Write-Host "Attempt $i to create submission..."

            try {
              $submission = Invoke-RestMethod `
                -Method POST `
                -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$appId/submissions" `
                -Headers @{ Authorization = "Bearer $token" } `
                -ContentType "application/json"

              Write-Host "Submission created successfully."
              $submission | ConvertTo-Json -Depth 20 | Out-File submission.json

              "SUBMISSION_ID=$($submission.id)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
              "UPLOAD_URL=$($submission.fileUploadUrl)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

              break
            }
            catch {
              $errorJson = $_.ErrorDetails.Message | ConvertFrom-Json

              if ($errorJson.code -eq "InvalidState") {
                Write-Host "Submission slot is busy. Waiting $delayMinutes minutes before retry..."
                Start-Sleep -Seconds ($delayMinutes * 60)
              }
              else {
                Write-Host "Unexpected error:"
                Write-Host $_
                exit 1
              }
            }
          }

          if (-not $submission) {
            Write-Error "Failed to create submission after $maxRetries attempts."
            exit 1
          }

          
      - name: Upload MSIX to Azure Blob
        shell: pwsh
        if: false
        run: |
          $uploadUrl = "${{ steps.create_submission.outputs.UPLOAD_URL }}"
          $file = "pdflinkcheck.msix"

          Write-Host "Uploading MSIX to Azure Blob..."
          Invoke-RestMethod -Method PUT -Uri $uploadUrl -InFile $file -ContentType "application/octet-stream"

      - name: Commit submission
        id: commit_submission
        if: false
        shell: pwsh
        run: |
          $token = "${{ steps.get_token.outputs.TOKEN }}"
          $appId = "9N11HXVLS1WG"
          $submissionId = "${{ steps.create_submission.outputs.SUBMISSION_ID }}"

          # Reload submission JSON
          $submission = Get-Content submission.json | ConvertFrom-Json

          # Commit the submission
          $result = Invoke-RestMethod `
            -Method PUT `
            -Uri "https://manage.devcenter.microsoft.com/v1.0/my/applications/$appId/submissions/$submissionId" `
            -Headers @{ Authorization = "Bearer $token" } `
            -Body ($submission | ConvertTo-Json -Depth 20) `
            -ContentType "application/json"

          Write-Host "Submission committed successfully."

      - name: Done
        run: |
          Write-Host "Microsoft Store submission created, uploaded, and committed."

      

